[{"id":0,"href":"/docs/monitor/top-9-cases-behind-cpu-high-usage/","title":"CPU使用达到100%的9个场景","section":"运维","content":"\n"},{"id":1,"href":"/docs/db/es/top-6-es-use-cases/","title":"ES使用最高的6个场景","section":"ElasticSearch","content":"\nTop 6 ElasticSearch Use Cases. . . Elasticsearch is widely used for its powerful and versatile search capabilities. The diagram below shows the top 6 use cases:\n🔹 Full-Text Search Elasticsearch excels in full-text search scenarios due to its robust, scalable, and fast search capabilities. It allows users to perform complex queries with near real-time responses.\n🔹 Real-Time Analytics Elasticsearch\u0026rsquo;s ability to perform analytics in real-time makes it suitable for dashboards that track live data, such as user activity, transactions, or sensor outputs.\n🔹 Machine Learning With the addition of the machine learning feature in X-Pack, Elasticsearch can automatically detect anomalies, patterns, and trends in the data.\n🔹 Geo-Data Applications Elasticsearch supports geo-data through geospatial indexing and searching capabilities. This is useful for applications that need to manage and visualize geographical information, such as mapping and location-based services.\n🔹 Log and Event Data Analysis Organizations use Elasticsearch to aggregate, monitor, and analyze logs and event data from various sources. It\u0026rsquo;s a key component of the ELK stack (Elasticsearch, Logstash, Kibana), which is popular for managing system and application logs to identify issues and monitor system health.\n🔹 Security Information and Event Management (SIEM) Elasticsearch can be used as a tool for SIEM, helping organizations to analyze security events in real time.\n"},{"id":2,"href":"/docs/code/block/mysql-batch-create-data/","title":"MySQL批量制造数据","section":"代码块","content":"利用mysql的存储过程快速插入大量数据\n1DELIMITER $$ 2 3USE `test`$$ 4 5DROP PROCEDURE IF EXISTS `add_user_batch`$$ 6 7CREATE DEFINER=`root`@`%` PROCEDURE `add_user_batch`(IN COUNT INT) 8BEGIN 9 DECLARE i INT; 10 DECLARE t_name VARCHAR(8); 11 DECLARE t_tag VARCHAR(20); 12 DECLARE t_age INT(2); 13 DECLARE t_sql_template VARCHAR(100); 14 DECLARE t_sql TEXT; 15 DECLARE t_tag_mod_val INT DEFAULT(25); 16 DECLARE t_commit_mod_val INT DEFAULT(100); 17 18 DECLARE t_start_time DATETIME; 19 DECLARE t_end_time DATETIME; 20 21 TRUNCATE TABLE `system_user`; 22 23 SET t_start_time=NOW(); 24 SET t_sql_template = \u0026#34;INSERT INTO `system_user`(NAME, age, tag) VALUES\u0026#34;; 25 SET t_sql = t_sql_template; 26 SET i = 1; 27 WHILE i \u0026lt;= COUNT 28 DO 29 SET t_age = FLOOR(1 + RAND() * 60); 30 SET t_name = LEFT(UUID(), 8); 31 -- 给tag随机制造空值 32 IF MOD(i, t_tag_mod_val) = 0 THEN 33 SET t_tag = \u0026#34;NULL\u0026#34;; 34 ELSE 35 SET t_tag = CONCAT(\u0026#34;\u0026#39;\u0026#34;,LEFT(UUID(), 8),\u0026#34;\u0026#39;\u0026#34;); 36 END IF; 37 38 SET t_sql = CONCAT(t_sql,\u0026#34;(\u0026#39;\u0026#34;,t_name,\u0026#34;\u0026#39;,\u0026#34;,t_age,\u0026#34;,\u0026#34;,t_tag,\u0026#34;)\u0026#34;); 39 40 IF MOD(i,t_commit_mod_val) != 0 THEN 41 SET t_sql = CONCAT(t_sql,\u0026#34;,\u0026#34;); 42 ELSE 43 SET t_sql = CONCAT(t_sql,\u0026#34;;\u0026#34;); 44 -- 只要达到t_commit_mod_val要求的次数，就执行并提交 45 SET @insert_sql = t_sql; 46 PREPARE stmt FROM @insert_sql; 47 EXECUTE stmt; 48 DEALLOCATE PREPARE stmt; 49 COMMIT; 50 SET t_sql=t_sql_template; 51 END IF; 52 SET i = i + 1; 53 END WHILE; 54 55 -- 不能被t_commit_mod_val整除时，余下的数据处理 56 IF LENGTH(t_sql) \u0026gt; LENGTH(t_sql_template) THEN 57 SET t_sql=CONCAT(SUBSTRING(t_sql,1,LENGTH(t_sql)-1),\u0026#39;;\u0026#39;); 58 SET @insert_sql = t_sql; 59 PREPARE stmt FROM @insert_sql; 60 EXECUTE stmt; 61 DEALLOCATE PREPARE stmt; 62 COMMIT; 63 END IF; 64 SET t_end_time=NOW(); 65 SELECT CONCAT(\u0026#39;insert data success,time cost \u0026#39;,TIMEDIFF(t_end_time,t_start_time)) AS finishedTag; 66END$$ 67 68DELIMITER ; "},{"id":3,"href":"/docs/other/stop-the-war/","title":"Stop The War","section":"其它","content":"\n"},{"id":4,"href":"/docs/network/tcp-status-change/","title":"TCP状态变化图","section":"网络","content":"\n"},{"id":5,"href":"/docs/security/identity-manage-types/","title":"不同的身份管理方式","section":"安全","content":"\n"},{"id":6,"href":"/docs/security/authentication-types-compare/","title":"不同认证方式的对比","section":"安全","content":"\n"},{"id":7,"href":"/docs/code/theory/language-compare/","title":"不同语言的工作原理","section":"理论","content":"\nHow Do C++, Java, Python Work?\nThe diagram shows how the compilation and execution work.\nCompiled languages are compiled into machine code by the compiler. The machine code can later be executed directly by the CPU. Examples: C, C++, Go.\nA bytecode language like Java, compiles the source code into bytecode first, then the JVM executes the program. Sometimes JIT (Just-In-Time) compiler compiles the source code into machine code to speed up the execution. Examples: Java, C#\nInterpreted languages are not compiled. They are interpreted by the interpreter during runtime. Examples: Python, Javascript, Ruby\nCompiled languages in general run faster than interpreted languages.\n"},{"id":8,"href":"/docs/cloud/cloud-tech-stack/","title":"云原生技术栈","section":"云原生","content":"\n"},{"id":9,"href":"/docs/linux/system/linux-file-system/","title":"文件类型说明","section":"Linux系统","content":"\nThe Linux file system used to resemble an unorganized town where individuals constructed their houses wherever they pleased. However, in 1994, the Filesystem Hierarchy Standard (FHS) was introduced to bring order to the Linux file system.\nBy implementing a standard like the FHS, software can ensure a consistent layout across various Linux distributions. Nonetheless, not all Linux distributions strictly adhere to this standard. They often incorporate their own unique elements or cater to specific requirements.\nTo become proficient in this standard, you can begin by exploring. Utilize commands such as \u0026ldquo;cd\u0026rdquo; for navigation and \u0026ldquo;ls\u0026rdquo; for listing directory contents. Imagine the file system as a tree, starting from the root (/). With time, it will become second nature to you, transforming you into a skilled Linux administrator.\n"},{"id":10,"href":"/docs/test/test-method-compare/","title":"测试方法对比","section":"测试","content":"\n"},{"id":11,"href":"/docs/code/java/thread-lifecycle/","title":"线程生命周期说明","section":"java","content":" 图解1 # 图解2 # "},{"id":12,"href":"/docs/microservice/develop/what-does-api-gateway-do/","title":"网关的作用","section":"微服务开发","content":"\n"},{"id":13,"href":"/docs/test/9-types-api-testing/","title":"9中API测试方式","section":"测试","content":"\nExplaining 9 types of API testing.\n🔹 Smoke Testing This is done after API development is complete. Simply validate if the APIs are working and nothing breaks.\n🔹 Functional Testing This creates a test plan based on the functional requirements and compares the results with the expected results.\n🔹 Integration Testing This test combines several API calls to perform end-to-end tests. The intra-service communications and data transmissions are tested.\n🔹 Regression Testing This test ensures that bug fixes or new features shouldn’t break the existing behaviors of APIs.\n🔹 Load Testing This tests applications’ performance by simulating different loads. Then we can calculate the capacity of the application.\n🔹 Stress Testing We deliberately create high loads to the APIs and test if the APIs are able to function normally.\n🔹 Security Testing This tests the APIs against all possible external threats.\n🔹 UI Testing This tests the UI interactions with the APIs to make sure the data can be displayed properly.\n🔹 Fuzz Testing This injects invalid or unexpected input data into the API and tries to crash the API. In this way, it identifies the API vulnerabilities.\n"},{"id":14,"href":"/docs/network/http-status/","title":"HTTP状态码说明","section":"网络","content":"\n"},{"id":15,"href":"/docs/code/block/matplotlib-show-chinese/","title":"Matplotlib展示中文","section":"代码块","content":"在Matplotlib中展示中文，防止乱码\n核心代码：\n1plt.rcParams[\u0026#39;font.sans-serif\u0026#39;]=[\u0026#39;SimHei\u0026#39;] #用来正常显示中文标签 2plt.rcParams[\u0026#39;axes.unicode_minus\u0026#39;] = False #用来正常显示负号 完整代码：\n1import numpy as np 2import matplotlib.pyplot as plt 3from sklearn.linear_model import Lasso 4 5plt.rcParams[\u0026#39;font.sans-serif\u0026#39;]=[\u0026#39;SimHei\u0026#39;] #用来正常显示中文标签 6plt.rcParams[\u0026#39;axes.unicode_minus\u0026#39;] = False #用来正常显示负号 7 8# 生成模拟数据 9np.random.seed(42) 10disciple_count = np.random.randint(50, 200, size=20) 11establishment_years = np.random.randint(1, 100, size=20) 12weapon_types = np.random.randint(1, 10, size=20) 13master_skill = 2 * disciple_count + 1.5 * establishment_years + 3 * weapon_types + np.random.randn(20) * 20 + 100 14 15# 数据转换为二维数组 16X = np.column_stack((disciple_count, establishment_years, weapon_types)) 17y = master_skill 18 19# 创建Lasso回归模型并训练 20lasso_reg = Lasso(alpha=0.1) 21lasso_reg.fit(X, y) 22 23# 打印模型参数 24print(\u0026#34;截距:\u0026#34;, lasso_reg.intercept_) 25print(\u0026#34;系数:\u0026#34;, lasso_reg.coef_) 26 27# 可视化回归平面（这里只能展示两个特征的二维平面图） 28plt.scatter(disciple_count, master_skill, color=\u0026#39;blue\u0026#39;, label=\u0026#39;实际数据\u0026#39;) 29plt.plot(disciple_count, lasso_reg.intercept_ + lasso_reg.coef_[0] * disciple_count + lasso_reg.coef_[1] * np.mean(establishment_years), color=\u0026#39;red\u0026#39;, linewidth=2, label=\u0026#39;回归直线\u0026#39;) 30plt.title(\u0026#34;武侠小说中的Lasso回归示例\u0026#34;) 31plt.xlabel(\u0026#34;弟子数量\u0026#34;) 32plt.ylabel(\u0026#34;掌门武功修为\u0026#34;) 33plt.legend() 34plt.show() "},{"id":16,"href":"/docs/other/how-visa-make-money/","title":"Visa是如何挣钱的","section":"其它","content":"\nWhy is the credit card called “𝐭𝐡𝐞 𝐦𝐨𝐬𝐭 𝐩𝐫𝐨𝐟𝐢𝐭𝐚𝐛𝐥𝐞 product in banks”? How does VISA/Mastercard make money?\nThe diagram below shows the economics of the credit card payment flow.\nThe cardholder pays a merchant $100 to buy a product.\nThe merchant benefits from the use of the credit card with higher sales volume, and needs to compensate the issuer and the card network for providing the payment service. The acquiring bank sets a fee with the merchant, called the “𝐦𝐞𝐫𝐜𝐡𝐚𝐧𝐭 𝐝𝐢𝐬𝐜𝐨𝐮𝐧𝐭 𝐟𝐞𝐞.”\n3 - 4. The acquiring bank keeps $0.25 as the 𝐚𝐜𝐪𝐮𝐢𝐫𝐢𝐧𝐠 𝐦𝐚𝐫𝐤𝐮𝐩, and $1.75 is paid to the issuing bank as the 𝐢𝐧𝐭𝐞𝐫𝐜𝐡𝐚𝐧𝐠𝐞 𝐟𝐞𝐞. The merchant discount fee should cover the interchange fee.\nThe interchange fee is set by the card network because it is less efficient for each issuing bank to negotiate fees with each merchant.\nThe card network sets up the 𝐧𝐞𝐭𝐰𝐨𝐫𝐤 𝐚𝐬𝐬𝐞𝐬𝐬𝐦𝐞𝐧𝐭𝐬 𝐚𝐧𝐝 𝐟𝐞𝐞𝐬 with each bank, which pays the card network for its services every month. For example, VISA charges a 0.11% assessment, plus a $0.0195 usage fee, for every swipe.\nThe cardholder pays the issuing bank for its services.\nWhy should the issuing bank be compensated? 🔹The issuer pays the merchant even if the cardholder fails to pay the issuer. 🔹The issuer pays the merchant before the cardholder pays the issuer. 🔹The issuer has other operating costs, including managing customer accounts, providing statements, fraud detection, risk management, clearing \u0026amp; settlement, etc.\nOver to you: Does the card network charge the same interchange fee for big merchants as for small merchants?\n"},{"id":17,"href":"/docs/linux/system/linux-file-permissions/","title":"文件权限说明","section":"Linux系统","content":"\n"},{"id":18,"href":"/docs/network/https-handshake/","title":"HTTPS连接建立过程","section":"网络","content":"\n"},{"id":19,"href":"/docs/security/session-vs-jwt/","title":"Session和JWT的对比","section":"安全","content":"\nWhat’s the difference between Session-based authentication and JWTs?\nHere’s a simple breakdown for both approaches:\nSession-Based Authentication\nIn this approach, you store the session information in a database or session store and hand over a session ID to the user.\nThink of it like a passenger getting just the Ticket ID of their flight while all other details are stored in the airline’s database.\nHere’s how it works:\n1 - The user makes a login request and the frontend app sends the request to the backend server.\n2 - The backend creates a session using a secret key and stores the data in session storage.\n3 - The server sends a cookie back to the client with the unique session ID.\n4 - The user makes a new request and the browser sends the session ID along with the request.\n5 - The server authenticates the user using the session ID.\nJWT-Based Authentication\nIn the JWT-based approach, you don’t store the session information in the session store.\nThe entire information is available within the token.\nThink of it like getting the flight ticket along with all the details available on the ticket but encoded.\nHere’s how it works:\n1 - The user makes a login request and it goes to the backend server.\n2 - The server verifies the credentials and issues a JWT. The JWT is signed using a private key and no session storage is involved.\n3 - The JWT is passed to the client, either as a cookie or in the response body. Both approaches have their pros and cons but we’ve gone with the cookie approach.\n4 - For every subsequent request, the browser sends the cookie with the JWT.\n5 - The server verifies the JWT using the secret private key and extracts the user info.\n"},{"id":20,"href":"/docs/network/how-https-works/","title":"HTTPS是如何工作的","section":"网络","content":"\nHTTPS: Safeguards your data from eavesdroppers and breaches. Understand how encryption and digital certificates create an impregnable shield.\nSSL Handshake: Behind the Scenes — Witness the cryptographic protocols that establish a secure connection. Experience the intricate exchange of keys and negotiation.\nSecure Data Transmission: Navigating the Tunnel — Journey through the encrypted tunnel forged by HTTPS. Learn how your information travels while shielded from cyber threats.\nHTML\u0026rsquo;s Role: Peek into HTML\u0026rsquo;s role in structuring the web. Uncover how hyperlinks and content come together seamlessly. And why is it called HYPER TEXT.\n"},{"id":21,"href":"/docs/microservice/develop/microservice-best-practices/","title":"微服务最佳实践","section":"微服务开发","content":"\n"}]